#!/usr/bin/env python3
"""
Gemini CLI Output Handler for Code Generation
Saves generated code to appropriate files based on language and context
"""

import sys
import json
import re
from pathlib import Path
from typing import Dict, Any, Optional

class CodeSaveHandler:
    """Handles saving generated code from Gemini CLI"""
    
    def __init__(self, output_dir: str = "."):
        self.output_dir = Path(output_dir)
        self.language_extensions = {
            "javascript": ".js",
            "typescript": ".ts",
            "swift": ".swift",
            "python": ".py",
            "sql": ".sql",
            "json": ".json",
            "yaml": ".yaml",
            "markdown": ".md"
        }
    
    def detect_language(self, content: str) -> Optional[str]:
        """Detect programming language from content"""
        patterns = {
            "javascript": r"(const |let |var |function |=>|module\.exports)",
            "typescript": r"(interface |type |enum |namespace |: string|: number)",
            "swift": r"(import SwiftUI|struct |class |func |var |let |@Published)",
            "python": r"(import |def |class |if __name__|from .* import)",
            "sql": r"(CREATE TABLE|SELECT |INSERT |UPDATE |DELETE |FROM )"
        }
        
        for lang, pattern in patterns.items():
            if re.search(pattern, content, re.IGNORECASE):
                return lang
        return None
    
    def extract_code_blocks(self, content: str) -> Dict[str, str]:
        """Extract code blocks from Gemini response"""
        code_blocks = {}
        
        # Find all code blocks with language markers
        pattern = r"```(\w+)?\n(.*?)```"
        matches = re.findall(pattern, content, re.DOTALL)
        
        for i, (lang, code) in enumerate(matches):
            if not lang:
                lang = self.detect_language(code) or "unknown"
            code_blocks[f"block_{i}_{lang}"] = code.strip()
        
        # If no code blocks found, treat entire content as code
        if not code_blocks and content.strip():
            lang = self.detect_language(content) or "unknown"
            code_blocks[f"block_0_{lang}"] = content.strip()
        
        return code_blocks
    
    def determine_file_path(self, code: str, language: str, context: Dict[str, Any]) -> Path:
        """Determine where to save the code based on content and context"""
        
        # Extract filename from code comments if present
        filename_match = re.search(r"//\s*filename:\s*(.+)|#\s*filename:\s*(.+)", code)
        if filename_match:
            filename = filename_match.group(1) or filename_match.group(2)
            return self.output_dir / filename.strip()
        
        # Use context hints if available
        if "task_id" in context:
            task_id = context["task_id"]
            
            # Map task IDs to expected file paths
            task_file_map = {
                "BE002": "backend/src/services/assemblyEngine.js",
                "BE003": "backend/src/services/costCalculator.js",
                "API001": "backend/src/routes/estimates.js",
                "IOS003": "ios-app/ContractorLens/AR/RoomScanner.swift",
                "INT001": "testing/integration/e2e.test.js"
            }
            
            if task_id in task_file_map:
                return self.output_dir / task_file_map[task_id]
        
        # Default naming based on language and content
        if language == "javascript":
            if "class AssemblyEngine" in code:
                return self.output_dir / "backend/src/services/assemblyEngine.js"
            elif "router." in code or "app." in code:
                return self.output_dir / "backend/src/routes/generated.js"
        elif language == "swift":
            if "RoomScanner" in code:
                return self.output_dir / "ios-app/ContractorLens/AR/RoomScanner.swift"
            elif "struct" in code:
                match = re.search(r"struct\s+(\w+)", code)
                if match:
                    return self.output_dir / f"ios-app/ContractorLens/Models/{match.group(1)}.swift"
        elif language == "sql":
            return self.output_dir / "database/generated.sql"
        
        # Fallback to generic naming
        ext = self.language_extensions.get(language, ".txt")
        return self.output_dir / f"generated_{language}{ext}"
    
    def save_code(self, code: str, file_path: Path) -> bool:
        """Save code to file with proper formatting"""
        try:
            # Create parent directories if needed
            file_path.parent.mkdir(parents=True, exist_ok=True)
            
            # Add file header if not present
            if file_path.suffix == ".js" and "/**" not in code[:50]:
                header = f"""/**
 * Generated by Gemini CLI for ContractorLens
 * File: {file_path.name}
 * Generated: {Path.ctime(Path.cwd())}
 */

"""
                code = header + code
            
            # Write the file
            file_path.write_text(code)
            print(f"‚úÖ Saved to {file_path}")
            return True
            
        except Exception as e:
            print(f"‚ùå Failed to save {file_path}: {e}")
            return False
    
    def process_response(self, response: str, context: Dict[str, Any] = None) -> Dict[str, Path]:
        """Process Gemini response and save all code blocks"""
        context = context or {}
        saved_files = {}
        
        # Extract code blocks
        code_blocks = self.extract_code_blocks(response)
        
        if not code_blocks:
            print("‚ö†Ô∏è No code blocks found in response")
            return saved_files
        
        # Save each code block
        for block_id, code in code_blocks.items():
            lang = block_id.split("_")[-1]
            file_path = self.determine_file_path(code, lang, context)
            
            if self.save_code(code, file_path):
                saved_files[block_id] = file_path
        
        return saved_files

def main():
    """Main entry point for Gemini CLI handler"""
    # Read from stdin (Gemini CLI pipes output here)
    response = sys.stdin.read()
    
    # Get context from environment or arguments
    context = {}
    if len(sys.argv) > 1:
        try:
            context = json.loads(sys.argv[1])
        except json.JSONDecodeError:
            context = {"task_id": sys.argv[1]} if sys.argv[1] else {}
    
    # Process and save
    handler = CodeSaveHandler(
        output_dir=context.get("output_dir", "/Users/mirzakhan/Projects/ContractorLens")
    )
    
    saved_files = handler.process_response(response, context)
    
    # Output results
    print(f"\nüìÅ Saved {len(saved_files)} file(s)")
    for block_id, path in saved_files.items():
        print(f"  - {path}")
    
    # Exit with appropriate code
    sys.exit(0 if saved_files else 1)

if __name__ == "__main__":
    main()
