# ContractorLens Backend CI/CD Pipeline
name: Backend CI/CD

on:
  push:
    branches: [main, develop]
    paths:
      - 'backend/**'
      - '.github/workflows/backend-ci-cd.yml'
  pull_request:
    branches: [main]
    paths:
      - 'backend/**'

env:
  AWS_REGION: us-west-2
  ECR_REPOSITORY: contractorlens-backend
  ECS_SERVICE: contractorlens
  ECS_CLUSTER: contractorlens
  ECS_TASK_DEFINITION: .aws/task-definition.json

jobs:
  test:
    name: Test Backend
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: contractorlens_test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
          cache-dependency-path: backend/package-lock.json

      - name: Install dependencies
        run: |
          cd backend
          npm ci

      - name: Setup test database
        env:
          PGPASSWORD: postgres
        run: |
          echo "---SCHEMA---"
          cat database/schemas/schema.sql
          echo "---MIGRATION---"
          cat database/migrations/V2__add_professional_estimate_tables.sql
          echo "---ITEMS---"
          cat database/seeds/items.sql
          echo "---ASSEMBLIES---"
          cat database/seeds/assemblies.sql
          echo "---ASSEMBLY ITEMS---"
          cat database/seeds/assembly_items.sql
          echo "---LOCATION MODIFIERS---"
          cat database/seeds/location_modifiers.sql
          echo "---TRADES---"
          cat database/seeds/trades.sql
          echo "---LABOR TASKS---"
          cat database/seeds/labor_tasks.sql
          echo "---MATERIAL SPECIFICATIONS---"
          cat database/seeds/material_specifications.sql

          # Apply the initial schema
          psql -h localhost -U postgres -d contractorlens_test -f database/schemas/schema.sql --set ON_ERROR_STOP=1
          
          # Apply the new V2 migration
          psql -h localhost -U postgres -d contractorlens_test -f database/migrations/V2__add_professional_estimate_tables.sql --set ON_ERROR_STOP=1
          
          # Seed the database with all necessary data
          psql -h localhost -U postgres -d contractorlens_test -f database/seeds/items.sql --set ON_ERROR_STOP=1
          psql -h localhost -U postgres -d contractorlens_test -f database/seeds/assemblies.sql --set ON_ERROR_STOP=1
          psql -h localhost -U postgres -d contractorlens_test -f database/seeds/assembly_items.sql --set ON_ERROR_STOP=1
          psql -h localhost -U postgres -d contractorlens_test -f database/seeds/location_modifiers.sql --set ON_ERROR_STOP=1
          psql -h localhost -U postgres -d contractorlens_test -f database/seeds/trades.sql --set ON_ERROR_STOP=1
          psql -h localhost -U postgres -d contractorlens_test -f database/seeds/labor_tasks.sql --set ON_ERROR_STOP=1
          psql -h localhost -U postgres -d contractorlens_test -f database/seeds/material_specifications.sql --set ON_ERROR_STOP=1

      - name: Run linting
        run: |
          cd backend
          npm run lint

      - name: Run unit tests
        run: |
          cd backend
          export DB_HOST=localhost
          export DB_PORT=5432
          export DB_NAME=contractorlens_test
          export DB_USER=postgres
          export DB_PASSWORD=postgres
          export NODE_ENV=test
          npm run test

      - name: Run security audit
        run: |
          cd backend
          npm audit --audit-level high

  build:
    name: Build and Push to ECR
    runs-on: ubuntu-latest
    needs: test
    if: github.ref == 'refs/heads/main'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build, tag, and push backend image to Amazon ECR
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          cd backend
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:latest .
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
          echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT

      - name: Build and push Gemini service image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          GEMINI_REPOSITORY: contractorlens-gemini
          IMAGE_TAG: ${{ github.sha }}
        run: |
          cd ml-services/gemini-service
          docker build -t $ECR_REGISTRY/$GEMINI_REPOSITORY:$IMAGE_TAG .
          docker build -t $ECR_REGISTRY/$GEMINI_REPOSITORY:latest .
          docker push $ECR_REGISTRY/$GEMINI_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$GEMINI_REPOSITORY:latest

      - name: Download task definition
        run: |
          aws ecs describe-task-definition --task-definition ${{ env.ECS_SERVICE }} --query taskDefinition > ${{ env.ECS_TASK_DEFINITION }}

      - name: Update Amazon ECS task definition with new image
        id: task-def
        uses: aws-actions/amazon-ecs-render-task-definition@v1
        with:
          task-definition: ${{ env.ECS_TASK_DEFINITION }}
          container-name: backend
          image: ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${{ github.sha }}

      - name: Deploy Amazon ECS task definition
        uses: aws-actions/amazon-ecs-deploy-task-definition@v1
        with:
          task-definition: ${{ steps.task-def.outputs.task-definition }}
          service: ${{ env.ECS_SERVICE }}
          cluster: ${{ env.ECS_CLUSTER }}
          wait-for-service-stability: true

  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: build
    if: github.ref == 'refs/heads/develop'
    environment: staging

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Deploy to staging ECS
        run: |
          aws ecs update-service \
            --cluster contractorlens-staging \
            --service contractorlens-staging \
            --force-new-deployment

      - name: Wait for deployment
        run: |
          aws ecs wait services-stable \
            --cluster contractorlens-staging \
            --services contractorlens-staging

      - name: Run smoke tests
        run: |
          # Wait for service to be ready
          sleep 60
          
          # Get load balancer URL from ECS service
          STAGING_URL=$(aws elbv2 describe-load-balancers \
            --names contractorlens-staging-alb \
            --query 'LoadBalancers[0].DNSName' \
            --output text)
          
          # Health check
          curl -f "http://$STAGING_URL/health" || exit 1
          
          # API smoke test
          curl -f "http://$STAGING_URL/api/v1/health" || exit 1
          
          echo "Staging deployment successful: http://$STAGING_URL"

  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: build
    if: github.ref == 'refs/heads/main'
    environment: production

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Blue-Green Deployment
        run: |
          # Get current task definition
          CURRENT_TASK_DEF=$(aws ecs describe-services \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ env.ECS_SERVICE }} \
            --query 'services[0].taskDefinition' \
            --output text)
          
          echo "Current task definition: $CURRENT_TASK_DEF"
          
          # Deploy new version
          aws ecs update-service \
            --cluster ${{ env.ECS_CLUSTER }} \
            --service ${{ env.ECS_SERVICE }} \
            --force-new-deployment
          
          # Wait for deployment to complete
          aws ecs wait services-stable \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ env.ECS_SERVICE }}

      - name: Production health checks
        run: |
          # Get production load balancer URL
          PROD_URL=$(aws elbv2 describe-load-balancers \
            --names contractorlens-alb \
            --query 'LoadBalancers[0].DNSName' \
            --output text)
          
          # Extended health checks
          for i in {1..10}; do
            echo "Health check attempt $i..."
            if curl -f "http://$PROD_URL/health"; then
              echo "Health check passed"
              break
            fi
            if [ $i -eq 10 ]; then
              echo "Health check failed after 10 attempts"
              exit 1
            fi
            sleep 30
          done
          
          # API functionality test
          curl -f "http://$PROD_URL/api/v1/health" || exit 1
          
          echo "Production deployment successful: http://$PROD_URL"

      - name: Send deployment notification
        if: always()
        run: |
          if [ "${{ job.status }}" == "success" ]; then
            echo "✅ Production deployment successful"
          else
            echo "❌ Production deployment failed"
          fi

  security-scan:
    name: Security Scan
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: './backend'
          format: 'sarif'
          output: 'trivy-results.sarif'

      - name: Upload Trivy scan results to GitHub Security tab
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: 'trivy-results.sarif'

  performance-test:
    name: Performance Test
    runs-on: ubuntu-latest
    needs: deploy-staging
    if: github.ref == 'refs/heads/develop'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Install k6
        run: |
          sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys C5AD17C747E3415A3642D57D77C6C491D6AC1D69
          echo "deb https://dl.k6.io/deb stable main" | sudo tee /etc/apt/sources.list.d/k6.list
          sudo apt-get update
          sudo apt-get install k6

      - name: Run performance tests
        run: |
          # Get staging URL
          STAGING_URL=$(aws elbv2 describe-load-balancers \
            --names contractorlens-staging-alb \
            --query 'LoadBalancers[0].DNSName' \
            --output text)
          
          # Run basic load test
          cat > loadtest.js << EOF
          import http from 'k6/http';
          import { check, sleep } from 'k6';
          
          export let options = {
            stages: [
              { duration: '2m', target: 10 },
              { duration: '5m', target: 10 },
              { duration: '2m', target: 0 },
            ],
            thresholds: {
              http_req_duration: ['p(95)<2000'],
            },
          };
          
          export default function() {
            let response = http.get('http://${STAGING_URL}/api/v1/health');
            check(response, {
              'status is 200': (r) => r.status === 200,
              'response time < 2s': (r) => r.timings.duration < 2000,
            });
            sleep(1);
          }
          EOF
          
          k6 run loadtest.js